---
layout: post
title:  "Efficiency Shefishency"
date:   2020-5-20 0:00:00 -0400
categories: new-blog
---

"If this was a good idea, someone would be doing it already."

I'm only now realizing the above comment isn't to be taken seriously. Of course, every good idea ever was invented at the point when no one else was doing it. When investors say the above, they aren't trying to claim that the perfectly efficient market, where when a new problem and solution are discovered mulitple teams simultaneously arise to implement.

Rather, they are asking something more fundamental - can you give a reason why this hasen't happened yet? More than that - can you be the one to bring your beautiful, baby idea to adulthood? 

For some technology, there is a clear reason why it wasn't in existance before this moment: the technology that makes it possible didn't exist. For other technologies, the clear reason _now_ is the time for the technology is a result of a changing market. Blah blah Uber because GPS because cell phones.


So, ok, I'll chill out with the tirade against "markets are always efficient," but for our own sakes can we rephrase the above as XXXX.






You can't really build a car until you had an engine ; the technology couldn't support it. 




 taken seriously. Of course, every 

There are probably some companies that started at the _wrong_time as far as history goes, but luckily, due to how the future is all uncertain or whatever, things still worked out. 

But 

This 

# Open Source ~Vibes~

Most of the little I know about writing software I learned in an open source context. It wasn't a terribly large open source community, but I was contributing to a codebase, in the open, and meeting other random people who decided - for their own reasons - they should be contributing too.

Defining what I mean by "open source context" is not so easy. There are obvious signifiers: the source code is visible, and you can contribute, and you can hopefully fork it and make changes. But there are other pieces of open source that are less obvious but still present: a community of maintainers (however large), and (un)written norms about how and where and in what ways to start and continue contributing.

# Remote First Work

Remote first is all the rage. Remote first means that people won't be disadvantaged in a company if they don't come into the office; the company will explicitly design procedures to make sure that all team members get an equal and fair "company expirence" - no matter if they are in person or not. As far as I can tell, this mostly just means more Zoom happy hours. 

Open source is a perfect example of remote first work. You can't miss anything at the office if there isn't one, after all. 

Of course, not all remote first work is open source work. There's the obvious first order difference: not all remote work is done in the open. But really, the more interesting differences have to do with how teams exist and interact. 

# The Nature of the Firm

The Coase theorem gives 

So: we can understand teams in open source and teams in companies as being different because company teams, even when they are doing remote work, have lower transaction costs from the perspective of "who can make edits."

But notably, they don't have an easier time actually making those edits.
- Async collab in open source is for making the edits.
- Distribution is for permissions.

So, we can lower the tx costs for teams with async collab in teams, and only for open source is the distributed approach really relevant (except as far as it leads to a better ux in certain cases).




Warning: I don't know what I'm talking about. 

But: Ronald 

Warning: below here we get into the real speculation

Open source, in all ways, fits the bill for remote first work. But not all remote first work, is open source, of course. There's the obvious different that most remote work isn't going to suddenly start appearing in the open - of course. But because it's 




Open source, in almost all ways, is remote first. Remote first 




I'm not a great open source community maintainer, and I've never really contributed to a large open source programming project. But I learned to program in an open source community - my first mentor is currently the head of the Ethereum Research codebase (which probably has 100's of contributors now) - and I still feel the open source spirit coursing through my veins. 

It's not worth my time (or yours) to try to give an explict definition 


